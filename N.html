<!DOCTYPE html>
<html lang="az">
<head>
<meta charset="UTF-8" />
<title>N</title>
<style>
  html, body {
    margin: 0; padding: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    user-select: none;
  }
  canvas {
    display: block;
    position: absolute;
    top: 0; left: 0;
  }
  #colorButtons {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 1000;
    display: flex;
    gap: 10px;
  }
  .color-btn {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid white;
    cursor: pointer;
    transition: transform 0.2s;
  }
  .color-btn:hover {
    transform: scale(1.2);
  }
</style>
</head>
<body>
<div id="colorButtons">
  <div id="redBtn" class="color-btn" style="background: #FF0000;" title="Qırmızı"></div>
  <div id="pinkBtn" class="color-btn" style="background: #FF69B4;" title="Pembe"></div>
  <div id="purpleBtn" class="color-btn" style="background: #800080;" title="Bənövşəyi"></div>
</div>

<canvas id="matrix"></canvas>
<canvas id="heartCanvas"></canvas>

<script>
let currentColor = "#FF69B4";

const matrix = document.getElementById("matrix");
const ctx = matrix.getContext("2d");

function resizeMatrix() {
  matrix.width = window.innerWidth;
  matrix.height = window.innerHeight;
}
resizeMatrix();
window.addEventListener('resize', resizeMatrix);

const fontSize = 24;
const word = "Nəzrin";
const columns = Math.floor(matrix.width / (fontSize * 4));
const positions = Array.from({ length: columns }, () => ({
  x: Math.random() * matrix.width,
  y: Math.random() * matrix.height,
}));

function drawMatrix() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
  ctx.fillRect(0, 0, matrix.width, matrix.height);

  ctx.fillStyle = currentColor; 
  ctx.font = fontSize + "px monospace";

  positions.forEach(pos => {
    ctx.fillText(word, pos.x, pos.y);
    pos.y += fontSize;
    if (pos.y > matrix.height || Math.random() > 0.975) {
      pos.x = Math.random() * matrix.width;
      pos.y = 0;
    }
  });
}
setInterval(drawMatrix, 50);

const heartCanvas = document.getElementById("heartCanvas");
const hctx = heartCanvas.getContext("2d");

function resizeHeartCanvas() {
  heartCanvas.width = window.innerWidth;
  heartCanvas.height = window.innerHeight;
}
resizeHeartCanvas();
window.addEventListener("resize", resizeHeartCanvas);

const scale = 6;
const centerX = heartCanvas.width / 2;
const centerY = heartCanvas.height / 2.5;

function heartPath(t, offsetX = 0, offsetY = 0) {
  let x = scale * 16 * Math.pow(Math.sin(t), 3);
  let y = -scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
  return { x: centerX + x + offsetX, y: centerY + y + offsetY };
}

function createHeartPath(offsetX = 0, offsetY = 0) {
  const points = [];
  for (let t = 0; t <= Math.PI * 2; t += 0.01) {
    points.push(heartPath(t, offsetX, offsetY));
  }
  return points;
}

const totalFrames = 60;
const stayFrames = 120;

class Heart {
  constructor(x, y) {
    this.offsetX = x - centerX;
    this.offsetY = y - centerY;
    this.points = createHeartPath(this.offsetX, this.offsetY);
    this.frame = 0;
    this.state = "drawing"; 
    this.opacity = 0;
  }

  update() {
    this.frame++;
    if (this.state === "drawing" && this.frame >= totalFrames) {
      this.state = "stay";
      this.frame = 0;
      this.opacity = 1;
    } else if (this.state === "stay" && this.frame >= stayFrames) {
      this.state = "fading";
      this.frame = 0;
    } else if (this.state === "fading" && this.frame >= totalFrames) {
      this.state = "done";
    }

    if (this.state === "drawing") {
      this.opacity = this.frame / totalFrames;
    }
    if (this.state === "fading") {
      this.opacity = 1 - this.frame / totalFrames;
      if (this.opacity < 0) this.opacity = 0;
    }
  }

  draw(ctx) {
    if (this.state === "done") return;

    const progress = this.state === "drawing" ? this.frame / totalFrames : 1;
    const visiblePoints = Math.floor(this.points.length * progress);

    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = `rgba(${hexToRgb(currentColor)},${this.opacity})`; 

    ctx.beginPath();
    for (let i = 0; i < visiblePoints - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.closePath();

    ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`;
    ctx.fill();

    ctx.stroke();

    if (progress > 0) {
      let fOpacity = this.opacity;
      ctx.font = `bold ${scale * 8}px monospace`; 
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = `rgba(${hexToRgb(currentColor)},${fOpacity})`; 
      ctx.fillText("N", centerX + this.offsetX, centerY + this.offsetY + 12);
    }
  }
}

const hearts = [];

function animate() {
  hctx.clearRect(0, 0, heartCanvas.width, heartCanvas.height);

  for (let i = hearts.length - 1; i >= 0; i--) {
    const heart = hearts[i];
    heart.update();
    heart.draw(hctx);
    if (heart.state === "done") {
      hearts.splice(i, 1);
    }
  }

  requestAnimationFrame(animate);
}
animate();

document.addEventListener("click", (e) => {
  hearts.push(new Heart(e.pageX, e.pageY));
});

document.getElementById("redBtn").addEventListener("click", () => {
  currentColor = "#FF0000";
});
document.getElementById("pinkBtn").addEventListener("click", () => {
  currentColor = "#FF69B4";
});
document.getElementById("purpleBtn").addEventListener("click", () => {
  currentColor = "#800080";
});

function hexToRgb(hex) {
  const bigint = parseInt(hex.slice(1), 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return `${r},${g},${b}`;
}
</script>
</body>
</html>
